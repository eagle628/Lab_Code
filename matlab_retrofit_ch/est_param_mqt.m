function [ out ] = est_param_mqt(model, option)
%[ out ] = est_param_proj_mqt(model, option)
%  ???C?????????}?????????J???[???g???@??????????????????????????e???^???V???X???e??????????????????
%
%  model: ?????????f????????????\?????????\???????????D?????????????t???B???[?????????h??????????????????
%   ???K???{???t???B???[?????????h
%     y : ???o?????????????l
%     params: ?????????m???p???????????????[???^??????\?????????Z?????????z??????@???i???V?????????{?????????b???N????????????????????????????j
%     params_init: ???p???????????????[???^??????????????l
%     sim???@?????????????@yhat??????dyhat: ?????????f?????????o?????????????x?????????????????v???Z??????????????????????n?????????h??????
%       sim???????????f?????????o?????????????x???????????????????????o???????????????????
%           [yhat dyhat] = model.sim(params,theta_hat);
%       yhat??????dyhat???????????????????????f?????????o?????????????x?????????????????o???????????????????
%           yhat = model.yhat(params,theta_hat);
%           dyhat = model.dyhat(params,theta_hat);
%
%   ??????K???{???t???B???[?????????h
%     w: ???d??????
%     H: ???G???????????????f??????
%
%  option: ????????????????????????????????????s?????????\????????????
%    callback: ???R???[?????????o???b???N????????
%       ???????????????????????????C
%           option.callback(itr,model,theta_hat,yhat,S,lambda);
%       ???????????????????D?????????????????????C????????????O??????itr=0???C??????????????????itr=inf ?????????n???????????????D
%           itr:??????????????????
%           theta_hat:???p???????????????[???^????????????l
%           yhat: ?????????f?????????o??????
%           S: ?????????????????a???i???]?????????????????j?????l
%           lambda: ???C?????????}?????????J???[???g???@????????????????????lambda
%    lambda: lambda??????????????l
%    maxitr: ?????????????????????????
%    gamma: ???????????????????????????????????@???????????????????????????????????????????W??????
%           S = (y-yhat)'*(y-yhat) + gamma.*theta_hat
%
%  out: ????????????????????????????\???????????D?????????????t???B???[?????????h??????????????????
%       theta: ???p???????????????[???^????????????l
%       yhat: ?????????f?????????o??????
%       P: ??????????????????????????????U???s??????
%       log: ?????????????????????????\?????????\???????????D?????????????t???B???[?????????h??????????????????
%           theta: ???p???????????????[???^????????????l
%           S:???@???]??????????????
%           lambda: ???C?????????}?????????J???[???g???@????????????????????lambda
%           cond: ??????????????????

% initialization
if isfield(model,'H')&&~isempty(model.H)
    H = model.H;
    y=lsim(1/H,model.y);
    hasH = true;
else
    hasH = false;
    y = model.y;
end

if isfield(model,'w')&&~isempty(model.w)
    w=model.w;
else
    w = 1;
end
if isfield(model,'sim')
    hasSim = true;
else
    hasSim = false;
end
if ~exist('option','var')
    option = struct;
end
if isfield(option,'maxitr')
    maxitr = option.maxitr;
else
    maxitr = 1000;
end
if isfield(option,'callback')
    callback = option.callback;
else
    %     callback = @(varargin) true;
    callback = @callback_std_mqt;
end

if isfield(option,'lambda')
    lambda = option.lambda;
else
    lambda = 0;
end

lambdac = 1e-5;

theta_hat=model.params_init(:);
params = model.params(:);
% norm_dyhat = zeros(size(params));
% norm_dypost = zeros(size(params));
% S = inf;
log_est.theta = zeros(numel(theta_hat),maxitr+1)';
log_est.S = zeros(maxitr+1,1);
log_est.lambda = zeros(maxitr+1,1);
log_est.cond = zeros(maxitr,1);
log_est.lambda(1) = lambda;
log_est.theta(1,:) = theta_hat';

if hasSim
    [yhat,dyhat] = model.sim(params,theta_hat);
else
    yhat=model.yhat(params, theta_hat);
    dyhat = model.dyhat(params,theta_hat);
end
if hasH
    yhat = lsim(1/H,yhat);
    for k=1:size(dyhat,2)
        dyhat(:,k) = lsim(1/H,dyhat(:,k));
    end
end
% for k=1:numel(params)
%     norm_dyhat(k) = norm(dyhat(:,k));
% end
% dyhat = bsxfun(@rdivide,dyhat,norm_dyhat');
[b,P_pri,S] = gen_mat(y,w,yhat,dyhat,theta_hat,option);
log_est.S(1) = S;
callback(0,model,theta_hat,yhat,S,lambda);
% try

for n = 1:maxitr;
    S1 = S;
    D = eye(size(dyhat,2))+diag(diag(P_pri));
    % Emphais diag elemnet
    P = P_pri+lambda*D;
    dx = (P\b);
    dS = -dx'*P*dx-lambda*dx'*D*dx;
%     dx = dx./norm_dyhat;
%     log_est.cond(n+1) = cond(P);
    % dx だけパラメータを動かしてみる
    try
        if hasSim
            [ypost,dypost] = model.sim(params,theta_hat+dx);
        else
            ypost=model.yhat(params, theta_hat+dx);
            dypost = model.dyhat(params,theta_hat+dx);
        end
        if hasH
            ypost = lsim(1/H,ypost);
            for k=1:size(dypost,2)
                dypost(:,k) = lsim(1/H,dypost(:,k));
            end
        end
%         for k=1:numel(params)
% %             norm_dypost(k) = norm(dypost(:,k));
%               norm_dypost(k) = sqrt(mean(dypost(:,k).^2));
%         end
%         dypost = bsxfun(@rdivide,dypost,norm_dypost');
        [bpost,Ppost_pri,Spost] = gen_mat(y,w,ypost,dypost,theta_hat+dx,option);
    catch m
        Spost=inf;
        %         m.message
    end
    %     ypost = model.yhat(model.params, theta_hat+dx);
    %     bpost = bsxfun(@times,(y-ypost),w);
    %     Spost = sum(bpost.^2);
    
    r = (Spost-S)/dS;
    if r>0
        theta_hat = theta_hat+dx;
        yhat = ypost;
        dyhat = dypost;
%         norm_dyhat = norm_dypost;
        b = bpost;
        S = Spost;
        P_pri = Ppost_pri;
        if r>=0.75
            lambda = lambda/2;
%             lambdac = 1/trace(P_pri\D);
%             if lambda<lambdac
%                 lambda = 0;
%             end
            
        elseif  r>0.25
            
        elseif r>=0
            % lamda param の変化量について
            if lambda <1e-9
%                 lambda = 1/trace(P_pri\D);
                lambda = lambdac;
            end
            lambda = lambda*max(2,min(2-r,10));
        end
    else
        if lambda < 1e-9
%             lambda = 1/trace(P_pri\D);
            lambda = lambdac;
        end
        lambda = lambda*max(2,min(2-r,10));
        %         dx = nan;
    end
    %         keyboard
    %     if isfield(option,'phi')
    %         phi = option.phi;
    %         callback(n,model,theta_hat,yhat+phi/(phi'*phi)*(phi'*(y-yhat)),S,lambda);
    %     else
    callback(n,model,theta_hat,yhat,S,lambda);
    %     end
    log_est.theta(n+1,:) = theta_hat';
    log_est.S(n+1)=S;
    log_est.lambda(n+1) = lambda;
    idx = abs(theta_hat)>1e-10;
    if (S1-S<=S*1e-7)&&all(abs(dx(idx))<=abs(theta_hat(idx))*1e-7)
        break;
    end
end
itr = n;

callback(inf,model,theta_hat,yhat,S,lambda);

%%
n=numel(y);
m=numel(theta_hat);
if ~isfield(option,'ar')
    sigma= std(y-yhat);
else
    sigma = option.sigma;
end
% sigma_y=std(yhat);
% P=sigma^2*eye(m)/P_pri;
% P=sigma^2*eye(m)/(dyhat'*dyhat);
% fprintf('\n');
% for k=1:m
%     fprintf('%-15s = % e (%f)\n',char(params{k}),theta_hat(k),sqrt(P(k,k))/abs(theta_hat(k)));
% end
% fprintf('\n');
log_est.theta = log_est.theta(1:itr+1,:);
log_est.S = log_est.S(1:itr+1);
log_est.lambda = log_est.lambda(1:itr+1);
log_est.cond = log_est.cond(1:itr);

out.log = log_est;
out.theta = theta_hat;
out.yhat = yhat;
out.e = y-yhat;
out.param = params2struct(params,theta_hat);
if isfield(option,'phi')
    phi = option.phi;
    out.theta_phi = (phi'*bsxfun(@times,phi,w))\(phi'*bsxfun(@times,(y-yhat),w));
end
% out.P = P;

if isfield(model,'exout')&&~isempty(model.exout)
out_ex = model.exout(out.param);
names = setdiff(fieldnames(out_ex),fieldnames(out));
for k=1:numel(names)
    out.(names{k}) = out_ex.(names{k});
end

end
end

function [b,P_pri,S] = gen_mat(y,w,yhat,dyhat,theta,option)

if islogical(w)
   aux = y(w)-yhat(w);
   S = aux'*aux;
   b = dyhat(w, :)'*aux;
   P_pri = dyhat(w, :)'*dyhat(w, :);
else
    aux = bsxfun(@times,(y-yhat),w);
    S = (y-yhat)'*aux;%error 2-norm
    b = dyhat' * aux;%beta
    P_pri=(dyhat)' *(bsxfun(@times,dyhat,w));%alpha
end

if isfield(option,'gamma')
    gamma = option.gamma(:);
    P_pri = P_pri + diag(gamma);
    b = b-bsxfun(@times,gamma,theta);
    S = S+theta'*bsxfun(@times,gamma,theta);
end
end

